---
title: Performance & Memory
description: Tips for optimizing performance and memory usage in Mystral Native.js
---

# Performance & Memory

This guide covers performance optimization and memory management in Mystral Native.js.

## V8 Heap Memory

When using V8 builds, complex scenes may encounter out-of-memory (OOM) errors due to V8's default heap size limits.

### Symptoms

- Application crashes after running for a few minutes
- Error messages about heap allocation failures
- Performance degradation over time

### Solution: Increase V8 Heap Size

You can increase V8's heap limit using the `V8_FLAGS` environment variable:

```bash
# macOS/Linux: Set max heap to 4GB (in bytes)
V8_FLAGS="--max-old-space-size=4096" mystral run game.js

# Or export it for the session
export V8_FLAGS="--max-old-space-size=4096"
mystral run game.js
```

Common heap sizes:
- `2048` (2GB) - Good for most games
- `4096` (4GB) - Complex scenes with many textures
- `8192` (8GB) - Very large worlds (Sponza, etc.)

### Windows

```powershell
$env:V8_FLAGS="--max-old-space-size=4096"
.\mystral.exe run game.js
```

## Shadow Memory Usage

Shadows can use significant GPU memory. For simple scenes or low-memory situations, disable shadows:

```javascript
import { Engine } from '@mystral/core';

const engine = new Engine({
  shadowsEnabled: false  // Saves ~160MB VRAM
});
```

Or with custom shadow settings:

```javascript
const engine = new Engine({
  shadow: {
    enabled: true,
    resolution: 512,  // Lower = less memory (default: 1024)
    maxLights: 1      // Fewer shadow-casting lights
  }
});
```

## Hot Reload for Development

Use watch mode to avoid restart overhead during development:

```bash
mystral run game.js --watch
```

This watches for file changes and automatically reloads the script, keeping WebGPU context initialized.

## Performance Tips

### 1. Minimize Allocations

Avoid creating objects in your render loop:

```javascript
// Bad - creates new vector every frame
function update() {
  const velocity = new Vector3(1, 0, 0);
  player.position.add(velocity);
}

// Good - reuse objects
const velocity = new Vector3(1, 0, 0);
function update() {
  player.position.add(velocity);
}
```

### 2. Use Instancing

For many similar objects, use instanced rendering:

```javascript
// Instead of 1000 separate meshes
const mesh = new InstancedMesh(geometry, material, 1000);
```

### 3. Level of Detail (LOD)

Reduce detail for distant objects:

```javascript
const lod = new LOD();
lod.addLevel(highDetailMesh, 0);    // Close
lod.addLevel(mediumDetailMesh, 50); // Medium distance
lod.addLevel(lowDetailMesh, 200);   // Far
```

### 4. Texture Optimization

- Use compressed textures (KTX2, Basis) when possible
- Match texture resolution to object screen size
- Use mipmaps for distant objects

## Profiling

### Frame Time

Log frame timing to identify bottlenecks:

```javascript
let lastTime = performance.now();
let frameCount = 0;

function render() {
  const now = performance.now();
  const delta = now - lastTime;
  lastTime = now;

  frameCount++;
  if (frameCount % 60 === 0) {
    console.log(`Frame time: ${delta.toFixed(2)}ms (${(1000/delta).toFixed(1)} FPS)`);
  }

  // Your render code...

  requestAnimationFrame(render);
}
```

### Memory

Check V8 heap usage periodically:

```javascript
// Note: This requires --expose-gc flag
if (typeof gc === 'function') {
  gc(); // Force garbage collection
}
console.log('Heap used:', process.memoryUsage?.().heapUsed / 1024 / 1024, 'MB');
```

## Known Limitations

1. **V8 GC Pauses** - Large heaps may cause occasional frame drops during garbage collection
2. **Texture Memory** - GPU memory usage is separate from V8 heap; monitor with platform tools
3. **macOS Audio Shutdown** - Process may exit with code 137 due to SDL3/CoreAudio interaction (audio works correctly during runtime)
