# JavaScript APIs

Mystral Native.js implements standard Web APIs for graphics, audio, networking, and input.

## Supported APIs

| API | Status | Notes |
|-----|--------|-------|
| WebGPU | Full | Core graphics API via Dawn or wgpu-native |
| Canvas 2D | Full | Skia-based implementation |
| Web Audio | Full | SDL3-based audio |
| fetch | Full | HTTP/HTTPS and file:// protocols |
| URL / URLSearchParams | Full | URL parsing and query string handling |
| Worker | Partial | Main-thread polyfill with async message passing |
| Blob | Full | Binary data containers |
| TextEncoder / TextDecoder | Full | UTF-8 encoding/decoding |
| Gamepad | Full | Controller support |
| requestAnimationFrame | Full | Frame timing |
| setTimeout/setInterval | Full | Timing functions |
| ES Modules | Full | import/export |
| TypeScript | Full | Via SWC transpilation |
| GLTF/GLB Loading | Full | Including Draco mesh compression |

## WebGPU

Full WebGPU API implementation via Dawn or wgpu-native.

```javascript
// Request adapter
const adapter = await navigator.gpu.requestAdapter({
    powerPreference: "high-performance"
});

// Request device
const device = await adapter.requestDevice();

// Get canvas context
const context = canvas.getContext("webgpu");
const format = navigator.gpu.getPreferredCanvasFormat();

context.configure({
    device,
    format,
    alphaMode: "premultiplied"
});

// Create shaders, pipelines, buffers, etc.
const shaderModule = device.createShaderModule({
    code: `
        @vertex fn vs() -> @builtin(position) vec4f { ... }
        @fragment fn fs() -> @location(0) vec4f { ... }
    `
});
```

## Canvas 2D

Skia-based 2D rendering context.

```javascript
const ctx = canvas.getContext("2d");

// Drawing operations
ctx.fillStyle = "#ff0000";
ctx.fillRect(10, 10, 100, 100);

ctx.strokeStyle = "#0000ff";
ctx.lineWidth = 2;
ctx.strokeRect(50, 50, 100, 100);

// Text
ctx.font = "24px sans-serif";
ctx.fillText("Hello World", 100, 100);

// Paths
ctx.beginPath();
ctx.arc(150, 150, 50, 0, Math.PI * 2);
ctx.fill();
```

## Web Audio

Full Web Audio API for sound playback and synthesis.

```javascript
const audioContext = new AudioContext();

// Load and decode audio
const response = await fetch("file://./sounds/music.mp3");
const arrayBuffer = await response.arrayBuffer();
const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

// Play audio
const source = audioContext.createBufferSource();
source.buffer = audioBuffer;
source.connect(audioContext.destination);
source.start();

// Audio processing
const gainNode = audioContext.createGain();
gainNode.gain.value = 0.5;
source.connect(gainNode);
gainNode.connect(audioContext.destination);
```

## fetch

HTTP/HTTPS requests and local file access.

```javascript
// Local files (relative to script)
const model = await fetch("file://./assets/model.glb");
const buffer = await model.arrayBuffer();

// Local files (absolute path)
const config = await fetch("file:///home/user/config.json");
const json = await config.json();

// HTTP/HTTPS
const response = await fetch("https://api.example.com/data");
const data = await response.json();

// POST request
const result = await fetch("https://api.example.com/upload", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ key: "value" })
});
```

## Gamepad

Standard Gamepad API for controller input.

```javascript
// Connection events
window.addEventListener("gamepadconnected", (e) => {
    console.log("Connected:", e.gamepad.id);
});

window.addEventListener("gamepaddisconnected", (e) => {
    console.log("Disconnected:", e.gamepad.id);
});

// Poll gamepad state in game loop
function update() {
    const gamepads = navigator.getGamepads();
    for (const gamepad of gamepads) {
        if (!gamepad) continue;

        // Axes (sticks)
        const leftX = gamepad.axes[0];  // -1 to 1
        const leftY = gamepad.axes[1];
        const rightX = gamepad.axes[2];
        const rightY = gamepad.axes[3];

        // Buttons
        const a = gamepad.buttons[0].pressed;
        const b = gamepad.buttons[1].pressed;
        const x = gamepad.buttons[2].pressed;
        const y = gamepad.buttons[3].pressed;
    }
}
```

## Keyboard Input

Standard keyboard events.

```javascript
window.addEventListener("keydown", (e) => {
    console.log("Key down:", e.key, e.code);
    if (e.key === "Escape") {
        // Handle escape
    }
});

window.addEventListener("keyup", (e) => {
    console.log("Key up:", e.key);
});
```

## Mouse Input

Standard mouse events.

```javascript
canvas.addEventListener("mousemove", (e) => {
    const x = e.clientX;
    const y = e.clientY;
});

canvas.addEventListener("mousedown", (e) => {
    console.log("Button:", e.button); // 0=left, 1=middle, 2=right
});

canvas.addEventListener("mouseup", (e) => {
    // Handle mouse up
});
```

## Timing

Animation frame and timing functions.

```javascript
// Animation loop
function render(timestamp) {
    // timestamp is in milliseconds
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    // Update and render
    update(deltaTime);
    draw();

    requestAnimationFrame(render);
}
requestAnimationFrame(render);

// Delayed execution
setTimeout(() => {
    console.log("Delayed");
}, 1000);

// Repeated execution
const intervalId = setInterval(() => {
    console.log("Tick");
}, 100);

// Cancel
clearInterval(intervalId);
```

## Console

Standard console API.

```javascript
console.log("Info message");
console.warn("Warning message");
console.error("Error message");
console.debug("Debug message");
```

## URL

Standard URL parsing and blob URL support.

```javascript
// Parse URLs
const url = new URL("https://example.com/path?key=value#hash");
console.log(url.hostname); // "example.com"
console.log(url.pathname); // "/path"

// Query parameters
const params = new URLSearchParams("foo=1&bar=2");
params.get("foo"); // "1"

// Blob URLs (used internally by libraries like Draco decoder)
const blob = new Blob(["console.log('hello')"]);
const blobUrl = URL.createObjectURL(blob);
URL.revokeObjectURL(blobUrl);
```

## Worker

Main-thread Worker polyfill that enables WebWorker-based libraries (like Draco mesh decoders) to function in the native runtime. Workers run on the main thread with async message passing via `setTimeout`.

```javascript
// Create a worker from a blob URL
const code = `self.onmessage = (e) => { postMessage(e.data * 2); };`;
const blob = new Blob([code]);
const url = URL.createObjectURL(blob);
const worker = new Worker(url);

worker.onmessage = (e) => console.log("Result:", e.data);
worker.postMessage(21); // Result: 42
worker.terminate();
```

### `importScripts` Support

The Worker polyfill supports `importScripts()`, matching the standard WebWorker behavior. Scripts are loaded synchronously from the embedded bundle or filesystem using `__readFileSync`, then executed via `eval`.

```javascript
// Inside worker code:
importScripts('draco_decoder.js');
importScripts('lib1.js', 'lib2.js'); // Multiple scripts supported
```

This enables libraries like the Draco mesh decoder to load their WASM glue code via `importScripts` without falling back to `fetch + eval`.

> **Note:** Workers run on the main thread, not in a separate thread. This is sufficient for libraries that use Workers for code isolation (like Draco) but won't provide parallel execution.

## Next Steps

- [Native APIs](/mystralnative/docs/api/native-apis) - Low-level `__`-prefixed native functions (`__decodeDraco`, `__readFileSync`, etc.)
- [Embedding](/mystralnative/docs/api/embedding) - Use as a C++ library
- [WebGPU Reference](https://www.w3.org/TR/webgpu/) - Full WebGPU spec
